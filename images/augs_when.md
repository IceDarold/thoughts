Окей, давай превратим твой `image_augs.py` в **боевой справочник**: где что жать, в каких задачах, и какие “пресеты” собирать.

> Кстати: часть старых файлов (PDF с задачами и т.п.), которые ты когда-то загружал, сейчас в этой сессии уже недоступна. Если нужно будет к ним вернуться — просто перезалей.

---

## 0. Общие принципы: как вообще думать про аугментации

1. **Train ≠ Val/Test**

   * Train: можно творить хаос (в пределах здравого смысла) — сильные ауги, шум, cutout, mixup.
   * Val/Test: только детерминированные вещи типа `resize_and_pad` / `center_crop`.

2. **Задача и инвариантность**

   * Если класс/таргет инвариантен к трансформации → можно использовать (напр. перевернуть кота — всё ещё кот).
   * Если трансформация меняет смысл (переворот цифр, текст, мед. снимки) → либо осторожно, либо вообще нет.

3. **Размер датасета**

   * Мало данных → нужны сильнее аугментации, но разумные.
   * Много данных → можно умереннее, акцент на лёгких аугах + maybe mixup/cutmix.

4. **Расхождение train/test**

   * Если в проде (или в hidden тесте) ожидаются «грязные» картинки (шум, разный свет) — стоит симулировать это.
   * Если данные очень чистые (рендеры, e-commerce с белым фоном) — не надо устраивать им кислотный фестиваль.

---

## 1. Когда какие аугментации уместны

### 1.1 Геометрия (flip, crop, rotate, resize)

**Что делает:** меняет положение/масштаб/кадрирование объекта.

**Хорошо работать:**

* Классификация natural images (животные, сцены, типичный Kaggle CV).
* Продуктовые фото (товар — в центре, ок чуть двигать/масштабировать).
* Видео-превью, обложки — если тебе важен общий «тип» контента, а не строгая геометрия.

**Хуже/опасно:**

* Текст/документы: поворот / vflip может испортить читабельность и менять задачу.
* Медицинские снимки, спутник, карты — ориентация и направление могут быть значимы.
* В задачах «по позиции» (keypoints, детекция без соответствующей аугментации боксов) — нужен синхронный ауг для разметки, которых у нас сейчас нет.

**Конкретно:**

* `random_horizontal_flip(p)`

  * Почти всегда ок для natural images / товаров.
  * Не использовать, если: есть текст, лого с направлением, асимметричные органы/структуры.

* `random_vertical_flip(p)`

  * Гораздо реже: только если нет понятия «верх-низ».
  * Пример: спутник, иногда — абстрактные текстуры.

* `random_resized_crop`

  * Main workhorse для классификации: смещает объект, меняет масштаб → модель меньше залипает на фиксированный центр.
  * Круто, когда объект не всегда идеально по центру в реальности.

* `random_crop` / `center_crop`

  * `random_crop` — более мягкая версия RRCrop (меньше масштабирующих приколов).
  * `center_crop` — для val/test или лёгкого train-аугмента: чуть режем края.

* `random_rotate`

  * Небольшие углы (±10–15°): норм, если ориентация не жизненно важна.
  * Не использовать в задачах с текстом, цифрами, мед. снимками (если только реально не надо).

---

### 1.2 Цвет (brightness / contrast / saturation / hue / grayscale / solarize / posterize / equalize / autocontrast)

**Что делает:** симулирует разные условия освещения/камеры/постобработки.

**Хорошо:**

* Natural images, товары, сцены, лица (в разумных пределах).
* Когда в реальности свет может быть очень разным.

**Опасно:**

* Там, где цвет — это часть смысла (например, датасет, где важно отличать метки по цвету).
* Документы/сканы: hue-сдвиг и сильная сатурация обычно вредят.
* Медицинские/спутник — цвет часто = каналы/физика, их лучше не крутить сильно.

**Конкретные штуки:**

* `random_color_jitter(...)`

  * Базовая «рабочая лошадь»: brightness+contrast+saturation+hue.
  * Умеренные параметры (0.1–0.3) в большинстве natural tasks → норма.

* `random_grayscale(p)`

  * Хорошая регуляризация в классификации: модель не переобучается на цветовые паттерны.
  * Не использовать, если цвет — ключевой признак класса.

* `random_solarize`, `random_posterize`

  * Это уже “strong augs” уровня RandAugment.
  * Использовать для очень сильного регуляризатора, когда данных мало, а задача — обычная классификация картинок.
  * Для задач «похожа ли картинка на реальную» (e-commerce, оценка качества, price from photo) — аккуратно, можно переборщить.

* `random_equalize`, `random_autocontrast`

  * Норм для задач, где разные камеры/экспозиции и надо выровнять контраст.
  * Можно добавить с небольшой вероятностью в mix.

---

### 1.3 Blur / Sharpness / Noise

**Зачем:** имитируем разные качества съёмки, фокус, шум матрицы.

* `random_gaussian_blur`

  * Помогает, если в проде будут размазанные кадры/скрины.
  * Если задача требует тонких деталей (мелкий текст) — не перебарщиваем.

* `random_sharpness`

  * Небольшой разброс вокруг 1 — нормальный способ сделать модель устойчивой к oversharpen/undersharpen картинкам.

* `random_gaussian_noise`, `random_salt_and_pepper`

  * Хороши, если в реальности будет шум (вебка, дешёвая камера, старые сканы).
  * Умеренно, иначе модель начнёт учиться игнорировать мелкие признаки.

---

### 1.4 Cutout / Random Erasing

**Идея:** частично закрываем объект → модель учится смотреть на глобальные признаки.

* Использовать:

  * Классификация объектов, где важна общая форма, контекст.
  * Когда хочешь бороться с тем, что модель залипает на один участок (логотип, угол).

* Осторожнее:

  * Если объект маленький → легко вырезать всё.
  * В задачах, где важен конкретный мелкий паттерн.

---

### 1.5 Mixup / CutMix

**Зачем:** мощная регуляризация, уменьшение переобучения, сглаживание decision boundary.

* Mixup:

  * Хорошо для **классификации** (особенно multi-class) с мало данных или с шумными лейблами.
  * Для regression задач (типа price) тоже можно, но осторожно: таргеты должны быть «разумно интерполябельны».

* CutMix:

  * Для объектов с локальными признаками (объекты на фоне) — часто работает лучше, чем mixup.
  * Для задач, где важен глобальный контекст, может быть чуть менее очевидно.

Не использовать:

* Когда метки нелинейно зависят от содержимого (например, странные кастомные таргеты).
* В detection/seg без продуманной адаптации лейблов.

---

## 2. Наборы аугментаций для разных случаев

Ниже — “рецепты”, которые можно собрать прямо из `image_augs.py`.

### 2.1 Классическая классификация natural images (типа CIFAR / Kaggle животных/сцен)

**Train (лёгкий вариант, когда данных достаточно):**

```python
from image_augs import (
    Compose, random_resized_crop, random_horizontal_flip,
    random_color_jitter, random_gaussian_blur
)

def build_light_classification_aug(size=(224, 224)):
    return Compose([
        random_resized_crop(size=size, scale=(0.8, 1.0)),
        random_horizontal_flip(p=0.5),
        random_color_jitter(0.1, 0.1, 0.1, 0.03, p=0.5),
        random_gaussian_blur(max_radius=1.0, p=0.2),
    ])
```

**Train (сильный, мало данных/сильное переобучение):**

Можно взять наш `build_default_strong_aug` и не мучиться:

```python
from image_augs import build_default_strong_aug

strong_aug = build_default_strong_aug(size=(224, 224))
```

Он уже включает:

* RandomResizedCrop
* HFlip
* OneOf(ColorJitter/Grayscale)
* OneOf(Blur/Sharpness)
* OneOf(Cutout/RandomErasing)

**Val/Test:**

```python
from image_augs import Compose, resize_and_pad

def build_eval_transform(size=(224, 224)):
    return Compose([
        lambda img: resize_and_pad(img, size=size),
    ])
```

---

### 2.2 Очень маленький датасет (1–3k картинок, обычная классификация)

Задача: максимально увеличить эффективный размер данных, не ломая семантику.

**Рецепт:**

* Сильный `random_resized_crop(scale=(0.5, 1.0))`
* HFlip
* ColorJitter посильнее
* Немного blur/noise
* Cutout / RandomErasing

```python
def build_small_data_aug(size=(224, 224)):
    return Compose([
        random_resized_crop(size=size, scale=(0.5, 1.0)),
        random_horizontal_flip(p=0.5),
        random_color_jitter(0.3, 0.3, 0.3, 0.05, p=0.8),
        random_gaussian_blur(max_radius=1.2, p=0.3),
        random_cutout(num_holes=1, max_hole_frac=0.4, p=0.5),
    ])
```

Mixup/CutMix сверху — если классификация и лосс это переварит.

---

### 2.3 Продуктовые/товарные картинки, price prediction, контент для рекоммендера

Это ближе к твоему миру: AutoPrice, embeddings для VK video и т.п.

Цели:

* Не превращать товар в сюрреализм.
* Оставить форму и цвет в адекватных пределах.
* Сделать модель устойчивой к свету/чуть другой кадрировке.

**Я бы взял:**

* Очень аккуратный `random_resized_crop` или просто `random_crop`.
* HFlip (если симметрия допустима; для некоторых товаров это ок, для некоторых — нет).
* Небольшой ColorJitter (0.1–0.2).
* Немного blur/noise для робастности.
* Без solarize/posterize/hue=0.2 — они делают слишком странные цвета.

```python
def build_product_aug(size=(224, 224)):
    return Compose([
        random_resized_crop(size=size, scale=(0.8, 1.0)),
        random_horizontal_flip(p=0.5),
        random_color_jitter(0.15, 0.15, 0.15, 0.03, p=0.6),
        random_gaussian_blur(max_radius=1.0, p=0.2),
        random_gaussian_noise(std=0.03, p=0.3),
    ])
```

Для **оценки/регрессии** (price) я бы не добавлял Cutout/CutMix/Mixup по умолчанию, пока не увидишь, что модель реально переобучается.

---

### 2.4 Документы, скрины, текст

Тут всё наоборот:

* Флипы/повороты — почти всегда зло.
* Hue/сильная сатурация — тоже.
* Хотим имитировать только разные сканеры, контраст, шум, crop краёв.

**Рецепт:**

```python
def build_doc_aug(size=(512, 512)):
    return Compose([
        # лёгкий random_crop/resize, чтобы симулировать разные поля сканирования
        random_resized_crop(size=size, scale=(0.9, 1.0), ratio=(0.9, 1.1)),
        random_brightness(max_delta=0.2, p=0.7),
        random_contrast(max_delta=0.2, p=0.7),
        random_gaussian_noise(std=0.02, p=0.4),
        random_autocontrast(p=0.3),
    ])
```

Не добавлял бы:

* hue/solarize/posterize
* flips/rotations (кроме, если задача специально инвариантна к этому).

---

### 2.5 Медицинские / спутник / карты (общая идея)

Если вдруг такой кейс прилетит:

* Важно: ось тела/света/направления может не быть инвариантной → HFlip/VFlip/Rotate либо нельзя, либо очень аккуратно.
* Цвет часто = каналы (например, MRI/CT/мультиспектральные снимки).

**Берём:**

* Лёгкие кропы/ресайзы (без flip/rotate).
* Немного шум/blur, если в реале много шума.
* Никакого hue/saturation jitter (если только знаешь, что значение в этом канале не критично).

---

### 2.6 Аугментации для обучения эмбеддингов (retrieval / CLIP-стайл)

Если ты будешь крутить свои визуальные эмбеддинги под рекоммендер:

* Нужно:

  * RRCrop / RandomCrop
  * HFlip
  * Лёгкий ColorJitter
  * Blur + немного шумов

* Осторожно:

  * Слишком странные ауги (solarize, posterize, жёсткий cutout) могут ухудшать instance-level matching, если от эмбеддинга ждёшь устойчивости к небольшим, но не огромным деформациям.

**Рецепт:**

```python
def build_embedding_aug(size=(224, 224)):
    return Compose([
        random_resized_crop(size=size, scale=(0.7, 1.0)),
        random_horizontal_flip(p=0.5),
        random_color_jitter(0.2, 0.2, 0.2, 0.05, p=0.8),
        random_gaussian_blur(max_radius=1.2, p=0.4),
        random_gaussian_noise(std=0.03, p=0.3),
    ])
```

Cutout/RandomErasing можно добавить с небольшой вероятностью, если ты хочешь, чтобы эмбеддинг не умирал от перекрытия объекта.

---

### 2.7 Test-Time Augmentation (TTA)

На олимпиаде TTA — это бесплатный (если успеваешь по времени) буст:

Типичный набор:

* Оригинал (resize+pad)
* HFlip
* Иногда: разные center-crop’ы / scale (чуть ближе/дальше)

Дальше усредняешь logits/предсказания.

Из наших кирпичей:

```python
def build_tta_transforms(size=(224, 224)):
    base = lambda img: resize_and_pad(img, size=size)
    hflipped = lambda img: hflip(resize_and_pad(img, size=size))
    return [base, hflipped]
```

Если хочется, можно добавить пару лёгких вариантов с маленьким сдвигом кропа.

---

## 3. Как этим пользоваться на туре

Чтобы не грузить голову во время тура:

1. **Перед туром** собрать 3–4 функции-предустановки:

   * `build_eval_transform`
   * `build_light_classification_aug`
   * `build_product_aug`
   * `build_embedding_aug`

2. В зависимости от задачи:

   * если классика/natural → light/strong классификационный;
   * если товары/цены/рекомендации → product-стайл;
   * если нужны эмбеддинги для контента → embedding-стайл.

3. На валидации использовать только eval-трансформ.

---

Если хочешь, можем следующим шагом разобрать конкретно:
**“есть табличка + image embeddings (как на АвтоПрайс)”** — какие аугментации имеет смысл делать *до* эмбеддингов (если ты сам их считаешь) и какие аугментации уже на табличных фичах/эмбедах вместо сырой картинки.
