кидаю тебе заготовку `AUGMENTATIONS.md`, чтобы можно было просто положить рядом с `image_augs.py`.

````markdown
# image_augs.py — справочник по аугментациям

Этот файл описывает все аугментации, реализованные в `image_augs.py`, и даёт рекомендации, как их комбинировать в ML-проекте (Kaggle/олимпиада).

Файл не зависит от `torch`/`torchvision` и работает только на **PIL + numpy**, так что его можно безопасно использовать в «чистом» окружении.

---

## 1. Базовые строительные блоки

### `set_seed(seed: int = 42)`

Фиксирует сиды для `random` и `numpy`, чтобы аугментации вели себя детерминированно при отладке и воспроизводимости экспериментов.

---

### `Compose`

```python
class Compose:
    def __init__(self, transforms: Sequence[Callable[[Image.Image], Image.Image]]):
        ...
    def __call__(self, img: Image.Image) -> Image.Image:
        ...
````

Последовательно применяет список трансформов к изображению — аналог `torchvision.transforms.Compose`.

**Пример:**

```python
aug = Compose([
    random_horizontal_flip(p=0.5),
    random_color_jitter(0.2, 0.2, 0.2, 0.05, p=0.8),
])
img_aug = aug(img)
```

---

### `RandomApply`

```python
RandomApply(transform, p: float = 0.5)
```

Оборачивает один трансформ и применяет его к изображению с вероятностью `p`.

Полезно, когда трансформ «тяжёлый» или сильно меняет картинку, и хочется лишь иногда его включать.

---

### `OneOf`

```python
OneOf(transforms: Sequence[Callable], p: float = 0.8)
```

С вероятностью `p` выбирает **один случайный** трансформ из списка и применяет его.
Если выпадет > `p`, возвращает исходное изображение.

Примеры:

* «либо color jitter, либо grayscale»
* «либо blur, либо sharpness»

---

## 2. Геометрические аугментации

### Базовые флипы

#### `hflip(img)`, `vflip(img)`

Детерминированные горизонтальный и вертикальный флип.

---

#### `random_horizontal_flip(p: float = 0.5)`

С вероятностью `p` разворачивает изображение по горизонтали.

Использование:

```python
aug = random_horizontal_flip(p=0.5)
img_aug = aug(img)
```

---

#### `random_vertical_flip(p: float = 0.5)`

Аналогично, но по вертикали.
Осторожнее в задачах, где вертикальное направление имеет смысл (напр. медицинские снимки, текст).

---

### Повороты

#### `random_rotate(max_degrees: float = 15.0, p: float = 0.5)`

С вероятностью `p` поворачивает картинку на угол в диапазоне `[-max_degrees, max_degrees]`.

Подходит для:

* natural images, где ориентация не критична;
* но не очень подходит для текста/документов, где разворот портит читаемость.

---

### Ресайзы и кропы

#### `resize(img, size: (W, H))`

Простой ресайз до ровного размера `(width, height)` с билинейной интерполяцией.

---

#### `pad_to_square(img, pad_color=(0, 0, 0))`

Добавляет паддинги, чтобы картинка стала квадратной, НЕ меняя масштаб.

Полезно, если:

* важно не «тянуть» объекты;
* архитектура ожидает квадратный вход.

---

#### `resize_and_pad(img, size=(W, H), pad_color=(0,0,0))`

Комбо:

1. Масштабируем картинку по **большей стороне** до `max(size)`.
2. Паддим до квадрата.
3. Ресайзим квадрат до `(W, H)`.

Частый вариант для классификации: приведение любой картинки к фиксированному размеру, сохраняя пропорции.

---

#### `center_crop(img, size=(W, H))`

Центральный кроп до `(W, H)`; если картинка меньше — предварительно масштабируется так, чтобы влезть.

---

#### `random_crop(size=(W, H))`

Случайный кроп заданного размера.
Если исходное изображение меньше — сначала масштабируется.

Использование:

```python
random_crop_224 = random_crop((224, 224))
img_aug = random_crop_224(img)
```

---

#### `random_resized_crop(size=(W, H),

```
                    scale=(0.6, 1.0),
                    ratio=(3/4, 4/3))`
```

Упрощённый аналог `RandomResizedCrop`:

1. Выбирает случайную площадь кропа как долю от исходной (`scale`).
2. Случайное соотношение сторон (`ratio`).
3. Кропает и ресайзит до `(W, H)`.

Это очень сильная геометрическая аугментация:

* меняет масштаб объекта;
* двигает его по кадру;
* может отрезать фон/контекст.

---

## 3. Цветовые аугментации

Все цветовые аугментации работают с RGB-картинками, чаще всего через:

* перевод в float `0..1`,
* изменение каналов,
* обратный перевод в uint8.

---

### Простые отдельные трансформы

#### `random_brightness(max_delta=0.2, p=0.8)`

Множит яркость на коэффициент из диапазона `[1-max_delta, 1+max_delta]`.

---

#### `random_contrast(max_delta=0.2, p=0.8)`

Регулирует контраст — картинка становится «бледнее» или «более жёсткой».

---

#### `random_saturation(max_delta=0.2, p=0.8)`

Меняет насыщенность цветов (через `ImageEnhance.Color`).

---

#### `random_hue(max_delta=0.05, p=0.8)`

Сдвигает оттенок в HSV-пространстве.
`max_delta` примерно в долях от 1 (0.05 ≈ слегка).

Сильно менять hue лучше не везде: для натуральных сцен умеренный сдвиг ок, для медицинских/технических — осторожно.

---

### Составной Color Jitter

#### `random_color_jitter(brightness=0.2,

```
                    contrast=0.2,
                    saturation=0.2,
                    hue=0.05,
                    p=0.8)`
```

Аналог `ColorJitter`:

* собирает список из включённых `brightness/contrast/saturation/hue`;
* случайно перемешивает их порядок;
* применяет с вероятностью `p`.

Очень удобен как «одна большая цветовая аугментация».

---

### Дополнительные цветовые эффекты

#### `random_grayscale(p=0.2)`

С вероятностью `p` превращает картинку в grayscale и обратно в RGB (3 одинаковых канала).

Помогает модели не переобучаться на «цветные подсказки».

---

#### `random_solarize(threshold=128, p=0.2)`

Solarize: инверсия ярких пикселей выше порога.
Довольно агрессивный эффект; чаще используется как часть очень сильного ауг-пайплайна.

---

#### `random_posterize(bits=4, p=0.2)`

Снижает количество бит на канал (квантование по цвету).

---

#### `random_equalize(p=0.2)`

Гистограммное equalize — улучшает контраст.

---

#### `random_autocontrast(p=0.2)`

Автоматически растягивает гистограмму по яркости в доступный диапазон.

---

## 4. Blur, Sharpness и Noise

### Размытие

#### `random_gaussian_blur(max_radius=1.5, p=0.5)`

С вероятностью `p` применяет `GaussianBlur` с радиусом от `0.1` до `max_radius`.

Имитация «смазанных» или расфокусированных кадров.

---

### Резкость

#### `random_sharpness(max_factor=0.5, p=0.5)`

Меняет резкость через `ImageEnhance.Sharpness`:

* `factor = 1` — исходное,
* `factor < 1` — мягче,
* `factor > 1` — резче.

---

### Шум

#### `random_gaussian_noise(std=0.05, p=0.5)`

Добавляет гауссов шум с дисперсией `std`.
`std ≈ 0.05` — заметный, но не убийственный шум.

---

#### `random_salt_and_pepper(amount=0.01, p=0.5)`

Часть пикселей (доля `amount`) случайно становитcя либо чёрной (0), либо белой (1).
Имитация артефактов/битых пикселей.

---

## 5. Cutout и Random Erasing

### `random_cutout(num_holes=1,

```
              max_hole_frac=0.5,
              fill_value=(0,0,0),
              p=0.5)`
```

Классический **Cutout**:

* выбирается `num_holes` прямоугольников случайного размера (до `max_hole_frac` от ширины/высоты),
* эти области заполняются цветом `fill_value`.

Заставляет модель быть устойчивее к частичному исчезновению объекта.

---

### `random_erasing(p=0.5,

```
               scale=(0.02, 0.33),
               ratio=(0.3, 3.3),
               fill_value=None,
               trials=10)`
```

**Random Erasing**:

* выбирается одна область случайного размера (доля площади `scale`) и аспекта (`ratio`),
* если `fill_value=None` — заполняется шумом,
* иначе — постоянным цветом.

В отличие от `random_cutout`, здесь больше контроля за площадью и формой.

---

## 6. Mixup и CutMix (для пар картинок)

Эти аугментации работают **не на одной картинке**, а на паре `(img1, img2)` + метки.

Важно: к ним нужно быть готовым в **лосс-функции** — метки тоже смешиваются.

---

### `mixup_images(img1, img2, alpha=0.4) -> (img_mix, lambda)`

* `lambda ~ Beta(alpha, alpha)` (если `alpha > 0`);
* результат = `lambda * img1 + (1-lambda) * img2` по пикселям;
* возвращает `(смешанная_картинка, λ)`.

Для меток в классификации:

```python
y_mix = lam * y1 + (1 - lam) * y2   # one-hot или soft-лейблы
```

---

### `cutmix_images(img1, img2, alpha=1.0) -> (img_cm, lambda)`

* Выбирается прямоугольник случайного размера (зависит от `alpha`).
* Вырезается и вставляется patch из `img2` в `img1`.
* Возвращает `(картинка, λ)`, где `λ` — фактическая доля площади от первой картинки (после учёта границ).

Метки:

```python
y_mix = lam * y1 + (1 - lam) * y2
```

CutMix чуть более «структурированный», чем Mixup: сохраняет куски объектов.

---

## 7. Готовый сильный пайплайн: `build_default_strong_aug`

```python
def build_default_strong_aug(size=(224, 224)) -> Callable[[Image.Image], Image.Image]:
    ...
```

Возвращает примерно такой пайплайн:

1. `random_resized_crop(size, scale=(0.6, 1.0))`
2. `random_horizontal_flip(p=0.5)`
3. `OneOf([color_jitter, grayscale], p=0.7)`
4. `OneOf([gaussian_blur, sharpness], p=0.5)`
5. `OneOf([cutout, random_erasing], p=0.5)`

Хорошая стартовая точка для **классификации** на естественных изображениях.

---

## 8. Типичный usage в проекте

```python
from PIL import Image
import image_augs as ia

ia.set_seed(42)

train_aug = ia.build_default_strong_aug(size=(224, 224))

img = Image.open("example.jpg").convert("RGB")
img_train = train_aug(img)
```

Если нужен более лёгкий пайплайн, можно собрать его вручную:

```python
light_aug = Compose([
    ia.random_resized_crop((224, 224), scale=(0.8, 1.0)),
    ia.random_horizontal_flip(p=0.5),
    ia.random_color_jitter(0.2, 0.2, 0.2, 0.05, p=0.5),
])
```

---

## 9. Замечания для соревнований и олимпиад

* **Detection/segmentation:**
  геометрические аугментации здесь требуют синхронных трансформаций разметки (bbox, mask). Код в этом файле работает **только с картинкой** — для детекции нужно дописывать логику для аннотаций.

* **Валидация и тест:**
  на валидации обычно используют только детерминированные трансформы: `resize`/`center_crop`/`resize_and_pad`.
  Сильные аугментации (rotate, jitter, cutout, mixup, cutmix) — только на обучении.

* **Интенсивность:**
  если модель нестабильна или данных мало, лучше начинать с мягкого набора: `RandomResizedCrop + HFlip + лёгкий ColorJitter`, и только потом подключать шум/blur/cutout.

---

Конец.

```

Если захочешь — можем потом к этому README добавить ещё кусок про то, как именно всё это встраивать в `torch.utils.data.Dataset`/`DataLoader` и как логично разделять train/val аугментации.

И небольшой орг-момент: часть файлов, которые ты загружал раньше (PDF с задачами и т.д.), в этой сессии уже недоступна — если нужно будет к ним вернуться, просто перезагрузи их заново.
::contentReference[oaicite:0]{index=0}
```
